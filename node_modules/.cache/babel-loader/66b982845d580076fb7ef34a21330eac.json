{"ast":null,"code":"var makeString = require('./helper/makeString');\n/**\n * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein\n */\n\n\nmodule.exports = function levenshtein(str1, str2) {\n  'use strict';\n\n  str1 = makeString(str1);\n  str2 = makeString(str2); // Short cut cases  \n\n  if (str1 === str2) return 0;\n  if (!str1 || !str2) return Math.max(str1.length, str2.length); // two rows\n\n  var prevRow = new Array(str2.length + 1); // initialise previous row\n\n  for (var i = 0; i < prevRow.length; ++i) {\n    prevRow[i] = i;\n  } // calculate current row distance from previous row\n\n\n  for (i = 0; i < str1.length; ++i) {\n    var nextCol = i + 1;\n\n    for (var j = 0; j < str2.length; ++j) {\n      var curCol = nextCol; // substution\n\n      nextCol = prevRow[j] + (str1.charAt(i) === str2.charAt(j) ? 0 : 1); // insertion\n\n      var tmp = curCol + 1;\n\n      if (nextCol > tmp) {\n        nextCol = tmp;\n      } // deletion\n\n\n      tmp = prevRow[j + 1] + 1;\n\n      if (nextCol > tmp) {\n        nextCol = tmp;\n      } // copy current col value into previous (in preparation for next iteration)\n\n\n      prevRow[j] = curCol;\n    } // copy last col value into previous (in preparation for next iteration)\n\n\n    prevRow[j] = nextCol;\n  }\n\n  return nextCol;\n};","map":{"version":3,"sources":["/Users/bentait/memrii/web/memriio_web/node_modules/underscore.string/levenshtein.js"],"names":["makeString","require","module","exports","levenshtein","str1","str2","Math","max","length","prevRow","Array","i","nextCol","j","curCol","charAt","tmp"],"mappings":"AAAA,IAAIA,UAAU,GAAGC,OAAO,CAAC,qBAAD,CAAxB;AAEA;;;;;AAGAC,MAAM,CAACC,OAAP,GAAiB,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiC;AAChD;;AACAD,EAAAA,IAAI,GAAGL,UAAU,CAACK,IAAD,CAAjB;AACAC,EAAAA,IAAI,GAAGN,UAAU,CAACM,IAAD,CAAjB,CAHgD,CAKhD;;AACA,MAAID,IAAI,KAAKC,IAAb,EAAmB,OAAO,CAAP;AACnB,MAAI,CAACD,IAAD,IAAS,CAACC,IAAd,EAAoB,OAAOC,IAAI,CAACC,GAAL,CAASH,IAAI,CAACI,MAAd,EAAsBH,IAAI,CAACG,MAA3B,CAAP,CAP4B,CAShD;;AACA,MAAIC,OAAO,GAAG,IAAIC,KAAJ,CAAUL,IAAI,CAACG,MAAL,GAAc,CAAxB,CAAd,CAVgD,CAYhD;;AACA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAACD,MAA5B,EAAoC,EAAEG,CAAtC,EAAyC;AACvCF,IAAAA,OAAO,CAACE,CAAD,CAAP,GAAaA,CAAb;AACD,GAf+C,CAiBhD;;;AACA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGP,IAAI,CAACI,MAArB,EAA6B,EAAEG,CAA/B,EAAkC;AAChC,QAAIC,OAAO,GAAGD,CAAC,GAAG,CAAlB;;AAEA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,IAAI,CAACG,MAAzB,EAAiC,EAAEK,CAAnC,EAAsC;AACpC,UAAIC,MAAM,GAAGF,OAAb,CADoC,CAGpC;;AACAA,MAAAA,OAAO,GAAGH,OAAO,CAACI,CAAD,CAAP,IAAgBT,IAAI,CAACW,MAAL,CAAYJ,CAAZ,MAAmBN,IAAI,CAACU,MAAL,CAAYF,CAAZ,CAApB,GAAsC,CAAtC,GAA0C,CAAzD,CAAV,CAJoC,CAKpC;;AACA,UAAIG,GAAG,GAAGF,MAAM,GAAG,CAAnB;;AACA,UAAIF,OAAO,GAAGI,GAAd,EAAmB;AACjBJ,QAAAA,OAAO,GAAGI,GAAV;AACD,OATmC,CAUpC;;;AACAA,MAAAA,GAAG,GAAGP,OAAO,CAACI,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAvB;;AACA,UAAID,OAAO,GAAGI,GAAd,EAAmB;AACjBJ,QAAAA,OAAO,GAAGI,GAAV;AACD,OAdmC,CAgBpC;;;AACAP,MAAAA,OAAO,CAACI,CAAD,CAAP,GAAaC,MAAb;AACD,KArB+B,CAuBhC;;;AACAL,IAAAA,OAAO,CAACI,CAAD,CAAP,GAAaD,OAAb;AACD;;AAED,SAAOA,OAAP;AACD,CA9CD","sourcesContent":["var makeString = require('./helper/makeString');\n\n/**\n * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein\n */\nmodule.exports = function levenshtein(str1, str2) {\n  'use strict';\n  str1 = makeString(str1);\n  str2 = makeString(str2);\n\n  // Short cut cases  \n  if (str1 === str2) return 0;\n  if (!str1 || !str2) return Math.max(str1.length, str2.length);\n\n  // two rows\n  var prevRow = new Array(str2.length + 1);\n\n  // initialise previous row\n  for (var i = 0; i < prevRow.length; ++i) {\n    prevRow[i] = i;\n  }\n\n  // calculate current row distance from previous row\n  for (i = 0; i < str1.length; ++i) {\n    var nextCol = i + 1;\n\n    for (var j = 0; j < str2.length; ++j) {\n      var curCol = nextCol;\n\n      // substution\n      nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );\n      // insertion\n      var tmp = curCol + 1;\n      if (nextCol > tmp) {\n        nextCol = tmp;\n      }\n      // deletion\n      tmp = prevRow[j + 1] + 1;\n      if (nextCol > tmp) {\n        nextCol = tmp;\n      }\n\n      // copy current col value into previous (in preparation for next iteration)\n      prevRow[j] = curCol;\n    }\n\n    // copy last col value into previous (in preparation for next iteration)\n    prevRow[j] = nextCol;\n  }\n\n  return nextCol;\n};\n"]},"metadata":{},"sourceType":"script"}
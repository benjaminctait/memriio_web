"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactMotion = require("react-motion");

var _immutabilityHelper = _interopRequireDefault(require("immutability-helper"));

var _reactMultiRef = _interopRequireDefault(require("react-multi-ref"));

var _OnUpdate = _interopRequireDefault(require("./OnUpdate"));

var _MoveContainer = _interopRequireDefault(require("./MoveContainer"));

/* eslint react/prop-types: "error" */
var DEFAULT_HEIGHT = {
  natural: 200,
  drag: 30
};

function getScrollSpeed(distance, speed, size) {
  // If distance is zero, then the result is the max speed. Otherwise,
  // the result tapers toward zero as it gets closer to the opposite
  // edge of the region.
  return Math.round(speed - speed / size * distance);
}

var DraggableList =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2["default"])(DraggableList, _React$Component);

  function DraggableList(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, DraggableList);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(DraggableList).call(this, props));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_itemRefs", new _reactMultiRef["default"]());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_autoScrollerTimer", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_listRef", React.createRef());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleTouchMove", function (e) {
      e.preventDefault();

      _this._handleMouseMove(e.touches[0]);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMouseMove", function (_ref) {
      var pageY = _ref.pageY,
          clientY = _ref.clientY;
      var _this$props = _this.props,
          list = _this$props.list,
          autoScrollMaxSpeed = _this$props.autoScrollMaxSpeed,
          autoScrollRegionSize = _this$props.autoScrollRegionSize;
      var _this$state = _this.state,
          dragging = _this$state.dragging,
          lastDrag = _this$state.lastDrag;
      if (!dragging || !lastDrag) return;

      var containerEl = _this._getContainer();

      var dragVisualIndex = _this._getDragVisualIndex();

      var keyFn = _this._getKeyFn();

      clearInterval(_this._autoScrollerTimer); // If the user has the mouse near the top or bottom of the container and
      // not at the end of the list, then autoscroll.

      if (dragVisualIndex !== 0 && dragVisualIndex !== list.length - 1) {
        var scrollSpeed = 0;
        var containerRect = containerEl && containerEl !== document.body && containerEl.getBoundingClientRect ? containerEl.getBoundingClientRect() : {
          top: 0,
          bottom: Infinity
        }; // Get the lowest of the screen top and the container top.

        var top = Math.max(0, containerRect.top);
        var distanceFromTop = clientY - top;

        if (distanceFromTop > 0 && distanceFromTop < autoScrollRegionSize) {
          scrollSpeed = -1 * getScrollSpeed(distanceFromTop, autoScrollMaxSpeed, autoScrollRegionSize);
        } else {
          // Get the lowest of the screen bottom and the container bottom.
          var bottom = Math.min(window.innerHeight, containerRect.bottom);
          var distanceFromBottom = bottom - clientY;

          if (distanceFromBottom > 0 && distanceFromBottom < autoScrollRegionSize) {
            scrollSpeed = getScrollSpeed(distanceFromBottom, autoScrollMaxSpeed, autoScrollRegionSize);
          }
        }

        if (scrollSpeed !== 0) {
          _this._scrollContainer(scrollSpeed);

          _this._autoScrollerTimer = setTimeout(function () {
            _this._handleMouseMove({
              pageY: pageY + (containerEl === document.body ? scrollSpeed : 0),
              clientY: clientY
            });
          }, 16);
        }
      }

      var containerScroll = !containerEl || containerEl === document.body ? 0 : containerEl.scrollTop;
      var mouseY = pageY - lastDrag.mouseOffset + containerScroll;

      if (_this.props.constrainDrag) {
        var visualList = _this._getVisualListDuringDrag();

        mouseY = Math.max(mouseY, _this._getDistanceFromTopDuringDrag(lastDrag, keyFn(visualList[0]), visualList));
        mouseY = Math.min(mouseY, _this._getDistanceFromTopDuringDrag(lastDrag, keyFn(visualList[visualList.length - 1]), visualList));
      }

      _this.setState({
        lastDrag: (0, _objectSpread2["default"])({}, lastDrag, {
          mouseY: mouseY
        })
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMouseUp", function () {
      clearInterval(_this._autoScrollerTimer);
      window.removeEventListener('mouseup', _this._handleMouseUp);
      window.removeEventListener('touchend', _this._handleMouseUp);
      window.removeEventListener('touchmove', _this._handleTouchMove);
      window.removeEventListener('mousemove', _this._handleMouseMove);
      if (document.documentElement) document.documentElement.style.cursor = '';
      _this._lastScrollDelta = 0;
      var _this$props2 = _this.props,
          list = _this$props2.list,
          onMoveEnd = _this$props2.onMoveEnd;
      var _this$state2 = _this.state,
          dragging = _this$state2.dragging,
          lastDrag = _this$state2.lastDrag;

      if (dragging && lastDrag && onMoveEnd) {
        var dragIndex = _this._getDragListIndex();

        var _newIndex = _this._getDragVisualIndex();

        if (dragIndex !== _newIndex) {
          var _newList = _this._getVisualListDuringDrag();

          onMoveEnd(_newList, list[dragIndex], dragIndex, _newIndex);
        }

        _this.setState({
          dragging: false
        });
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_lastScrollDelta", 0);
    _this.state = {
      useAbsolutePositioning: false,
      dragging: false,
      lastDrag: null,
      heights: null
    };
    return _this;
  }

  (0, _createClass2["default"])(DraggableList, [{
    key: "getItemInstance",
    value: function getItemInstance(key) {
      var ref = this._itemRefs.map.get(key);

      if (!ref) throw new Error('key not found');
      return ref.getTemplate();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._handleMouseUp();
    }
  }, {
    key: "_handleTouchStart",
    value: function _handleTouchStart(itemKey, pressY, event) {
      event.stopPropagation();

      this._handleStartDrag(itemKey, pressY, event.touches[0].pageY);
    }
  }, {
    key: "_handleMouseDown",
    value: function _handleMouseDown(itemKey, pressY, event) {
      event.preventDefault();

      this._handleStartDrag(itemKey, pressY, event.pageY);
    }
  }, {
    key: "_handleStartDrag",
    value: function _handleStartDrag(itemKey, pressY, pageY) {
      var _this2 = this;

      if (document.documentElement) document.documentElement.style.cursor = 'move';
      window.addEventListener('mouseup', this._handleMouseUp);
      window.addEventListener('touchend', this._handleMouseUp);
      window.addEventListener('touchmove', this._handleTouchMove);
      window.addEventListener('mousemove', this._handleMouseMove); // If an element has focus while we drag around the parent, some browsers
      // try to scroll the parent element to keep the focused element in view.
      // Stop that.

      {
        var listEl = this._listRef.current;
        if (!listEl) throw new Error('Should not happen');

        if (listEl.contains && document.activeElement && listEl.contains(document.activeElement)) {
          document.activeElement.blur();
        }
      }

      var keyFn = this._getKeyFn();

      var newHeights = null;

      if (this.state.heights == null) {
        var _newHeights = Object.create(null);

        this.props.list.forEach(function (item) {
          var key = keyFn(item);

          var containerRef = _this2._itemRefs.map.get(key);

          var refEl = containerRef ? containerRef.getDOMNode().firstElementChild : null;
          var ref = containerRef ? containerRef.getTemplate() : null;
          var natural = refEl instanceof HTMLElement ? refEl.offsetHeight : DEFAULT_HEIGHT.natural;
          var drag = ref && typeof ref.getDragHeight === 'function' && ref.getDragHeight() || natural;
          _newHeights[key] = {
            natural: natural,
            drag: drag
          };
        });
        newHeights = _newHeights;
      } // Need to re-render once before we start dragging so that the `y` values
      // are set using the correct state.heights and then can animate from there.


      var afterHeights = function afterHeights() {
        var itemIndex = _this2.props.list.map(keyFn).indexOf(itemKey); // pressY will be non-null if the list is currently animating (because the
        // clicked item has its `y` prop set). pressY will be null if the list is
        // not currently animating (because the clicked item will be at its
        // natural position, which is calculatable using _getDistance).


        var startY = pressY == null ? _this2._getDistance(0, itemIndex, false) : pressY;

        var containerEl = _this2._getContainer();

        var containerScroll = !containerEl || containerEl === document.body ? 0 : containerEl.scrollTop;

        _this2.setState({
          useAbsolutePositioning: true,
          dragging: true,
          lastDrag: {
            itemKey: itemKey,
            startY: startY,
            mouseY: startY,
            mouseOffset: pageY - startY + containerScroll
          }
        });
      };

      if (newHeights) {
        this.setState({
          heights: newHeights
        }, afterHeights);
      } else {
        afterHeights();
      }
    }
  }, {
    key: "_scrollContainer",
    value: function _scrollContainer(delta) {
      var containerEl = this._getContainer();

      if (!containerEl) return;

      if (window.scrollBy && containerEl === document.body) {
        window.scrollBy(0, delta);
      } else {
        containerEl.scrollTop += delta;
      }
    }
  }, {
    key: "_adjustScrollAtEnd",
    value: function _adjustScrollAtEnd(delta) {
      var frameDelta = Math.round(delta - this._lastScrollDelta);

      this._scrollContainer(frameDelta);

      this._lastScrollDelta += frameDelta;
    }
  }, {
    key: "_getDragListIndex",
    value: function _getDragListIndex() {
      var list = this.props.list;
      var lastDrag = this.state.lastDrag;

      if (!lastDrag) {
        throw new Error('No drag happened');
      }

      var keyFn = this._getKeyFn();

      return DraggableList._getIndexOfItemWithKey(keyFn, list, lastDrag.itemKey);
    }
  }, {
    key: "_getDragVisualIndex",
    value: function _getDragVisualIndex() {
      var _this$props3 = this.props,
          list = _this$props3.list,
          padding = _this$props3.padding;
      var _this$state3 = this.state,
          dragging = _this$state3.dragging,
          lastDrag = _this$state3.lastDrag;
      if (!dragging || !lastDrag) throw new Error('Should not happen');

      var dragListIndex = this._getDragListIndex();

      var mouseY = lastDrag.mouseY,
          startY = lastDrag.startY;
      var movementFromNatural = mouseY - startY; // 1 down, -1 up, 0 neither

      var direction = movementFromNatural > 0 ? 1 : movementFromNatural < 0 ? -1 : 0;
      var newIndex = dragListIndex;

      if (direction !== 0) {
        var keyFn = this._getKeyFn();

        var reach = Math.abs(movementFromNatural);

        for (var i = dragListIndex + direction; i < list.length && i >= 0; i += direction) {
          var iDragHeight = this._getItemHeight(keyFn(list[i])).drag;

          if (reach < iDragHeight / 2 + padding) break;
          reach -= iDragHeight + padding;
          newIndex = i;
        }
      }

      return newIndex;
    }
  }, {
    key: "_getVisualListDuringDrag",
    value: function _getVisualListDuringDrag() {
      var list = this.props.list;
      var _this$state4 = this.state,
          dragging = _this$state4.dragging,
          lastDrag = _this$state4.lastDrag;
      if (!dragging || !lastDrag) throw new Error('Should not happen: _getVisualListDuringDrag called outside of drag');

      var dragListIndex = this._getDragListIndex();

      var dragVisualIndex = this._getDragVisualIndex();

      return (0, _immutabilityHelper["default"])(list, {
        $splice: [[dragListIndex, 1], [dragVisualIndex, 0, list[dragListIndex]]]
      });
    }
  }, {
    key: "_getItemHeight",
    value: function _getItemHeight(key) {
      return this.state.heights != null && key in this.state.heights ? this.state.heights[key] : DEFAULT_HEIGHT;
    } // Get the distance between the tops of two items in the list.
    // Does not consider how the dragged item may be rendered in a different position
    // unless you pass in the re-ordered list as a parameter.

  }, {
    key: "_getDistance",
    value: function _getDistance(start, end, dragging) {
      var list = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.props.list;

      if (end < start) {
        return -this._getDistance(end, start, dragging, list);
      }

      var padding = this.props.padding;

      var keyFn = this._getKeyFn();

      var distance = 0;

      for (var i = start; i < end; i++) {
        var height = this._getItemHeight(keyFn(list[i]));

        distance += (dragging ? height.drag : height.natural) + padding;
      }

      return distance;
    }
  }, {
    key: "_getDistanceFromTopDuringDrag",
    value: function _getDistanceFromTopDuringDrag(lastDrag, itemKey, visualList) {
      var keyFn = this._getKeyFn();

      var index = DraggableList._getIndexOfItemWithKey(keyFn, visualList, itemKey);

      var dragListIndex = this._getDragListIndex();

      var dragVisualIndex = DraggableList._getIndexOfItemWithKey(keyFn, visualList, lastDrag.itemKey);

      var offset = 0;

      if (dragVisualIndex < dragListIndex) {
        var dragItemHeight = this._getItemHeight(lastDrag.itemKey);

        var newCenterHeight = this._getItemHeight(keyFn(visualList[dragListIndex]));

        offset = dragItemHeight.drag - newCenterHeight.drag;
      }

      return lastDrag.startY + offset + this._getDistance(dragListIndex, index, true, visualList);
    }
  }, {
    key: "_getContainer",
    value: function _getContainer() {
      var container = this.props.container;
      return container ? container() : null;
    }
  }, {
    key: "_getKeyFn",
    value: function _getKeyFn() {
      return DraggableList._getKeyFn(this.props.itemKey);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props4 = this.props,
          list = _this$props4.list,
          springConfig = _this$props4.springConfig,
          container = _this$props4.container,
          padding = _this$props4.padding,
          template = _this$props4.template,
          unsetZIndex = _this$props4.unsetZIndex,
          commonProps = _this$props4.commonProps;
      var _this$state5 = this.state,
          dragging = _this$state5.dragging,
          lastDrag = _this$state5.lastDrag,
          useAbsolutePositioning = _this$state5.useAbsolutePositioning;

      var keyFn = this._getKeyFn();

      var anySelected = (0, _reactMotion.spring)(dragging ? 1 : 0, springConfig);
      var visualList = dragging ? this._getVisualListDuringDrag() : list;
      var children = list.map(function (item, i) {
        var key = keyFn(item);
        var selectedStyle = dragging && lastDrag && lastDrag.itemKey === key ? {
          itemSelected: (0, _reactMotion.spring)(1, springConfig),
          y: lastDrag.mouseY
        } : {
          itemSelected: (0, _reactMotion.spring)(0, springConfig),
          y: (useAbsolutePositioning ? _reactMotion.spring : function (x, ignored) {
            return x;
          })(dragging && lastDrag ? _this3._getDistanceFromTopDuringDrag(lastDrag, key, visualList) : _this3._getDistance(0, i, false), springConfig)
        };
        var style = (0, _objectSpread2["default"])({
          anySelected: anySelected
        }, selectedStyle);

        var makeDragHandleProps = function makeDragHandleProps(getY) {
          return {
            onMouseDown: function onMouseDown(e) {
              return _this3._handleMouseDown(key, getY(), e);
            },
            onTouchStart: function onTouchStart(e) {
              return _this3._handleTouchStart(key, getY(), e);
            }
          };
        };

        var height = _this3._getItemHeight(key);

        return React.createElement(_reactMotion.Motion, {
          style: style,
          key: key,
          children: function children(_ref2) {
            var itemSelected = _ref2.itemSelected,
                anySelected = _ref2.anySelected,
                y = _ref2.y;
            return React.createElement(_MoveContainer["default"], {
              ref: _this3._itemRefs.ref(key),
              y: useAbsolutePositioning ? y : null,
              template: template,
              padding: padding,
              item: item,
              itemSelected: itemSelected,
              anySelected: anySelected,
              height: height,
              zIndex: unsetZIndex && !useAbsolutePositioning ? 'auto' : lastDrag && lastDrag.itemKey === key ? list.length : i,
              makeDragHandleProps: makeDragHandleProps,
              commonProps: commonProps
            });
          }
        });
      });
      var adjustScroll = 0;

      if (!dragging && lastDrag && useAbsolutePositioning) {
        var dragListIndex = this._getDragListIndex();

        adjustScroll = (0, _reactMotion.spring)(this._getDistance(0, dragListIndex, false) - lastDrag.mouseY, springConfig);
      }

      var heightReserverHeight = 0;
      var heightReserverMarginBottom = 0;

      if (list.length) {
        heightReserverMarginBottom = padding;

        if (useAbsolutePositioning) {
          heightReserverHeight = this._getDistance(0, list.length, false) - padding;
        }
      }

      return React.createElement("div", {
        style: {
          position: 'relative'
        },
        ref: this._listRef
      }, React.createElement(_reactMotion.Motion, {
        style: {
          adjustScroll: adjustScroll,
          anySelected: anySelected
        },
        onRest: function onRest() {
          if (!dragging) {
            _this3.setState({
              heights: null,
              useAbsolutePositioning: false
            });
          }
        },
        children: function children(_ref3) {
          var adjustScroll = _ref3.adjustScroll;
          return React.createElement("div", {
            style: {
              display: useAbsolutePositioning ? 'block' : 'none',
              height: "".concat(heightReserverHeight, "px"),
              marginBottom: "".concat(heightReserverMarginBottom, "px")
            }
          }, container && React.createElement(_OnUpdate["default"], {
            cb: function cb() {
              if (!dragging && lastDrag && useAbsolutePositioning) {
                _this3._adjustScrollAtEnd(adjustScroll);
              }
            }
          }));
        }
      }), children);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(newProps, state) {
      var list = newProps.list;
      var lastDrag = state.lastDrag;

      if (lastDrag) {
        var keyFn = DraggableList._getKeyFn(newProps.itemKey);

        try {
          DraggableList._getIndexOfItemWithKey(keyFn, list, lastDrag.itemKey);
        } catch (err) {
          // If the dragged item was removed from the list, this block will get hit.
          // Cancel the drag.
          return {
            dragging: false,
            lastDrag: null
          };
        }
      }

      return null;
    }
  }, {
    key: "_getIndexOfItemWithKey",
    value: function _getIndexOfItemWithKey(keyFn, list, itemKey) {
      for (var i = 0, len = list.length; i < len; i++) {
        if (keyFn(list[i]) === itemKey) {
          return i;
        }
      }

      throw new Error('Failed to find drag index');
    }
  }, {
    key: "_getKeyFn",
    value: function _getKeyFn(itemKey) {
      return typeof itemKey === 'function' ? itemKey : function (x) {
        return x[itemKey];
      };
    }
  }]);
  return DraggableList;
}(React.Component);

exports["default"] = DraggableList;
(0, _defineProperty2["default"])(DraggableList, "propTypes", {
  itemKey: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].func]).isRequired,
  template: _propTypes["default"].func,
  list: _propTypes["default"].array.isRequired,
  onMoveEnd: _propTypes["default"].func,
  container: _propTypes["default"].func,
  springConfig: _propTypes["default"].object,
  constrainDrag: _propTypes["default"].bool,
  padding: _propTypes["default"].number,
  unsetZIndex: _propTypes["default"].bool,
  autoScrollMaxSpeed: _propTypes["default"].number.isRequired,
  autoScrollRegionSize: _propTypes["default"].number.isRequired,
  commonProps: _propTypes["default"].object
});
(0, _defineProperty2["default"])(DraggableList, "defaultProps", {
  springConfig: {
    stiffness: 300,
    damping: 50
  },
  padding: 10,
  unsetZIndex: false,
  constrainDrag: false,
  autoScrollMaxSpeed: 15,
  autoScrollRegionSize: 30
});
module.exports = exports.default;
module.exports.default = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX0hFSUdIVCIsIm5hdHVyYWwiLCJkcmFnIiwiZ2V0U2Nyb2xsU3BlZWQiLCJkaXN0YW5jZSIsInNwZWVkIiwic2l6ZSIsIk1hdGgiLCJyb3VuZCIsIkRyYWdnYWJsZUxpc3QiLCJwcm9wcyIsIk11bHRpUmVmIiwiUmVhY3QiLCJjcmVhdGVSZWYiLCJlIiwicHJldmVudERlZmF1bHQiLCJfaGFuZGxlTW91c2VNb3ZlIiwidG91Y2hlcyIsInBhZ2VZIiwiY2xpZW50WSIsImxpc3QiLCJhdXRvU2Nyb2xsTWF4U3BlZWQiLCJhdXRvU2Nyb2xsUmVnaW9uU2l6ZSIsInN0YXRlIiwiZHJhZ2dpbmciLCJsYXN0RHJhZyIsImNvbnRhaW5lckVsIiwiX2dldENvbnRhaW5lciIsImRyYWdWaXN1YWxJbmRleCIsIl9nZXREcmFnVmlzdWFsSW5kZXgiLCJrZXlGbiIsIl9nZXRLZXlGbiIsImNsZWFySW50ZXJ2YWwiLCJfYXV0b1Njcm9sbGVyVGltZXIiLCJsZW5ndGgiLCJzY3JvbGxTcGVlZCIsImNvbnRhaW5lclJlY3QiLCJkb2N1bWVudCIsImJvZHkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJib3R0b20iLCJJbmZpbml0eSIsIm1heCIsImRpc3RhbmNlRnJvbVRvcCIsIm1pbiIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiZGlzdGFuY2VGcm9tQm90dG9tIiwiX3Njcm9sbENvbnRhaW5lciIsInNldFRpbWVvdXQiLCJjb250YWluZXJTY3JvbGwiLCJzY3JvbGxUb3AiLCJtb3VzZVkiLCJtb3VzZU9mZnNldCIsImNvbnN0cmFpbkRyYWciLCJ2aXN1YWxMaXN0IiwiX2dldFZpc3VhbExpc3REdXJpbmdEcmFnIiwiX2dldERpc3RhbmNlRnJvbVRvcER1cmluZ0RyYWciLCJzZXRTdGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfaGFuZGxlTW91c2VVcCIsIl9oYW5kbGVUb3VjaE1vdmUiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsImN1cnNvciIsIl9sYXN0U2Nyb2xsRGVsdGEiLCJvbk1vdmVFbmQiLCJkcmFnSW5kZXgiLCJfZ2V0RHJhZ0xpc3RJbmRleCIsIm5ld0luZGV4IiwibmV3TGlzdCIsInVzZUFic29sdXRlUG9zaXRpb25pbmciLCJoZWlnaHRzIiwia2V5IiwicmVmIiwiX2l0ZW1SZWZzIiwibWFwIiwiZ2V0IiwiRXJyb3IiLCJnZXRUZW1wbGF0ZSIsIml0ZW1LZXkiLCJwcmVzc1kiLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsIl9oYW5kbGVTdGFydERyYWciLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdEVsIiwiX2xpc3RSZWYiLCJjdXJyZW50IiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsIm5ld0hlaWdodHMiLCJfbmV3SGVpZ2h0cyIsIk9iamVjdCIsImNyZWF0ZSIsImZvckVhY2giLCJpdGVtIiwiY29udGFpbmVyUmVmIiwicmVmRWwiLCJnZXRET01Ob2RlIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJIVE1MRWxlbWVudCIsIm9mZnNldEhlaWdodCIsImdldERyYWdIZWlnaHQiLCJhZnRlckhlaWdodHMiLCJpdGVtSW5kZXgiLCJpbmRleE9mIiwic3RhcnRZIiwiX2dldERpc3RhbmNlIiwiZGVsdGEiLCJzY3JvbGxCeSIsImZyYW1lRGVsdGEiLCJfZ2V0SW5kZXhPZkl0ZW1XaXRoS2V5IiwicGFkZGluZyIsImRyYWdMaXN0SW5kZXgiLCJtb3ZlbWVudEZyb21OYXR1cmFsIiwiZGlyZWN0aW9uIiwicmVhY2giLCJhYnMiLCJpIiwiaURyYWdIZWlnaHQiLCJfZ2V0SXRlbUhlaWdodCIsIiRzcGxpY2UiLCJzdGFydCIsImVuZCIsImhlaWdodCIsImluZGV4Iiwib2Zmc2V0IiwiZHJhZ0l0ZW1IZWlnaHQiLCJuZXdDZW50ZXJIZWlnaHQiLCJjb250YWluZXIiLCJzcHJpbmdDb25maWciLCJ0ZW1wbGF0ZSIsInVuc2V0WkluZGV4IiwiY29tbW9uUHJvcHMiLCJhbnlTZWxlY3RlZCIsImNoaWxkcmVuIiwic2VsZWN0ZWRTdHlsZSIsIml0ZW1TZWxlY3RlZCIsInkiLCJzcHJpbmciLCJ4IiwiaWdub3JlZCIsIm1ha2VEcmFnSGFuZGxlUHJvcHMiLCJnZXRZIiwib25Nb3VzZURvd24iLCJfaGFuZGxlTW91c2VEb3duIiwib25Ub3VjaFN0YXJ0IiwiX2hhbmRsZVRvdWNoU3RhcnQiLCJhZGp1c3RTY3JvbGwiLCJoZWlnaHRSZXNlcnZlckhlaWdodCIsImhlaWdodFJlc2VydmVyTWFyZ2luQm90dG9tIiwicG9zaXRpb24iLCJkaXNwbGF5IiwibWFyZ2luQm90dG9tIiwiX2FkanVzdFNjcm9sbEF0RW5kIiwibmV3UHJvcHMiLCJlcnIiLCJsZW4iLCJDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJmdW5jIiwiaXNSZXF1aXJlZCIsImFycmF5Iiwib2JqZWN0IiwiYm9vbCIsIm51bWJlciIsInN0aWZmbmVzcyIsImRhbXBpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQVJBO0FBZUEsSUFBTUEsY0FBMEIsR0FBRztBQUFDQyxFQUFBQSxPQUFPLEVBQUUsR0FBVjtBQUFlQyxFQUFBQSxJQUFJLEVBQUU7QUFBckIsQ0FBbkM7O0FBRUEsU0FBU0MsY0FBVCxDQUF3QkMsUUFBeEIsRUFBa0NDLEtBQWxDLEVBQXlDQyxJQUF6QyxFQUErQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFPQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0gsS0FBSyxHQUFJQSxLQUFLLEdBQUdDLElBQVQsR0FBaUJGLFFBQXBDLENBQVA7QUFDRDs7SUEwRG9CSyxhOzs7OztBQStCbkIseUJBQVlDLEtBQVosRUFBaUM7QUFBQTs7QUFBQTtBQUMvQix5SEFBTUEsS0FBTjtBQUQrQixrR0FMcUIsSUFBSUMseUJBQUosRUFLckI7QUFBQTtBQUFBLGlHQUZ0QkMsS0FBSyxD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QSxPQUFPLEVBQUVpRixzQkFBVUMsU0FBVixDQUFvQixDQUMzQkQsc0JBQVVFLE1BRGlCLEVBRTNCRixzQkFBVUcsSUFGaUIsQ0FBcEIsRUFHTkMsVUFKYztBQUtqQmhDLEVBQUFBLFFBQVEsRUFBRTRCLHNCQUFVRyxJQUxIO0FBTWpCakosRUFBQUEsSUFBSSxFQUFFOEksc0JBQVVLLEtBQVYsQ0FBZ0JELFVBTkw7QUFPakJuRyxFQUFBQSxTQUFTLEVBQUUrRixzQkFBVUcsSUFQSjtBQVFqQmpDLEVBQUFBLFNBQVMsRUFBRThCLHNCQUFVRyxJQVJKO0FBU2pCaEMsRUFBQUEsWUFBWSxFQUFFNkIsc0JBQVVNLE1BVFA7QUFVakJqSCxFQUFBQSxhQUFhLEVBQUUyRyxzQkFBVU8sSUFWUjtBQVdqQnRELEVBQUFBLE9BQU8sRUFBRStDLHNCQUFVUSxNQVhGO0FBWWpCbkMsRUFBQUEsV0FBVyxFQUFFMkIsc0JBQVVPLElBWk47QUFhakJwSixFQUFBQSxrQkFBa0IsRUFBRTZJLHNCQUFVUSxNQUFWLENBQWlCSixVQWJwQjtBQWNqQmhKLEVBQUFBLG9CQUFvQixFQUFFNEksc0JBQVVRLE1BQVYsQ0FBaUJKLFVBZHRCO0FBZWpCOUIsRUFBQUEsV0FBVyxFQUFFMEIsc0JBQVVNO0FBZk4sQztpQ0FEQS9KLGEsa0JBa0JpQjtBQUNsQzRILEVBQUFBLFlBQVksRUFBRTtBQUFDc0MsSUFBQUEsU0FBUyxFQUFFLEdBQVo7QUFBaUJDLElBQUFBLE9BQU8sRUFBRTtBQUExQixHQURvQjtBQUVsQ3pELEVBQUFBLE9BQU8sRUFBRSxFQUZ5QjtBQUdsQ29CLEVBQUFBLFdBQVcsRUFBRSxLQUhxQjtBQUlsQ2hGLEVBQUFBLGFBQWEsRUFBRSxLQUptQjtBQUtsQ2xDLEVBQUFBLGtCQUFrQixFQUFFLEVBTGM7QUFNbENDLEVBQUFBLG9CQUFvQixFQUFFO0FBTlksQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG4vKiBlc2xpbnQgcmVhY3QvcHJvcC10eXBlczogXCJlcnJvclwiICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQge01vdGlvbiwgc3ByaW5nfSBmcm9tICdyZWFjdC1tb3Rpb24nO1xuaW1wb3J0IHVwZGF0ZSBmcm9tICdpbW11dGFiaWxpdHktaGVscGVyJztcbmltcG9ydCBNdWx0aVJlZiBmcm9tICdyZWFjdC1tdWx0aS1yZWYnO1xuaW1wb3J0IE9uVXBkYXRlIGZyb20gJy4vT25VcGRhdGUnO1xuaW1wb3J0IE1vdmVDb250YWluZXIgZnJvbSAnLi9Nb3ZlQ29udGFpbmVyJztcblxudHlwZSBIZWlnaHREYXRhID0ge3xcbiAgbmF0dXJhbDogbnVtYmVyO1xuICBkcmFnOiBudW1iZXI7XG58fTtcblxuY29uc3QgREVGQVVMVF9IRUlHSFQ6IEhlaWdodERhdGEgPSB7bmF0dXJhbDogMjAwLCBkcmFnOiAzMH07XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFNwZWVkKGRpc3RhbmNlLCBzcGVlZCwgc2l6ZSkge1xuICAvLyBJZiBkaXN0YW5jZSBpcyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgaXMgdGhlIG1heCBzcGVlZC4gT3RoZXJ3aXNlLFxuICAvLyB0aGUgcmVzdWx0IHRhcGVycyB0b3dhcmQgemVybyBhcyBpdCBnZXRzIGNsb3NlciB0byB0aGUgb3Bwb3NpdGVcbiAgLy8gZWRnZSBvZiB0aGUgcmVnaW9uLlxuICByZXR1cm4gTWF0aC5yb3VuZChzcGVlZCAtIChzcGVlZCAvIHNpemUpICogZGlzdGFuY2UpO1xufVxuXG50eXBlIERyYWcgPSB7XG4gIGl0ZW1LZXk6IHN0cmluZztcblxuICAvLyBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBpdGVtIHdoZW4gdGhlIGRyYWcgc3RhcnRlZC4gVGhpcyB3aWxsIGJlXG4gIC8vIGVxdWFsIHRvIHRoZSBpbml0aWFsIG1vdXNlWSB2YWx1ZS4gVGhlIGl0ZW1zIG5vdCBiZWluZyBkcmFnZ2VkIHdpbGwgYmVcbiAgLy8gcG9zaXRpb25lZCBzbyB0aGF0IHRoZSBkcmFnZ2VkIGl0ZW0ncyBvcmlnaW5hbCBwb3NpdGlvbiBsaW5lcyB1cCB3aXRoXG4gIC8vIHN0YXJ0WS5cbiAgc3RhcnRZOiBudW1iZXI7XG5cbiAgLy8gVGhlIHktcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbW91c2UncyBjdXJyZW50IGxvY2F0aW9uLiBUaGVcbiAgLy8gZHJhZ2dlZCBpdGVtIHdpbGwgYmUgcmVuZGVyZWQgd2l0aCB0aGlzIGFzIGl0cyB5LXBvc2l0aW9uLlxuICBtb3VzZVk6IG51bWJlcjtcblxuICAvLyBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHJhdyBtb3VzZSB5IHZhbHVlIGFuZCBzdGFydFkuIEZvclxuICAvLyBleGFtcGxlLCBpZiBhIHVzZXIgY2xpY2tzIHRoZSBkcmFnIGhhbmRsZSBhdCBhIHBvaW50IDUgcHggYmVsb3cgdGhlIGl0ZW0nc1xuICAvLyB0b3AsIHRoZW4gbW91c2VPZmZzZXQgd2lsbCBiZSBzZXQgdG8gNS4gQXMgdGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2UsIHdlXG4gIC8vIHVwZGF0ZSBtb3VzZVkgdG8gYmUgdGhlIHJhdyBtb3VzZSB5IHZhbHVlIG1pbnVzIG1vdXNlT2Zmc2V0LlxuICBtb3VzZU9mZnNldDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVGVtcGxhdGVQcm9wczxJLEM+ID0ge1xuICBpdGVtOiBJO1xuICBpdGVtU2VsZWN0ZWQ6IG51bWJlcjtcbiAgYW55U2VsZWN0ZWQ6IG51bWJlcjtcbiAgZHJhZ0hhbmRsZVByb3BzOiBPYmplY3Q7XG4gIGNvbW1vblByb3BzOiBDO1xufTtcblxudHlwZSBQcm9wczxJLEMsVD4gPSB7XG4gIGl0ZW1LZXk6IHN0cmluZ3woaXRlbTogSSk9PnN0cmluZztcbiAgdGVtcGxhdGU6IENsYXNzPFQ+O1xuICBsaXN0OiAkUmVhZE9ubHlBcnJheTxJPjtcbiAgb25Nb3ZlRW5kPzogPyhuZXdMaXN0OiAkUmVhZE9ubHlBcnJheTxJPiwgbW92ZWRJdGVtOiBJLCBvbGRJbmRleDogbnVtYmVyLCBuZXdJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICBjb250YWluZXI/OiA/KCkgPT4gP0hUTUxFbGVtZW50O1xuICBjb25zdHJhaW5EcmFnOiBib29sZWFuO1xuICBzcHJpbmdDb25maWc6IE9iamVjdDtcbiAgcGFkZGluZzogbnVtYmVyO1xuICB1bnNldFpJbmRleDogYm9vbGVhbjtcbiAgYXV0b1Njcm9sbE1heFNwZWVkOiBudW1iZXI7XG4gIGF1dG9TY3JvbGxSZWdpb25TaXplOiBudW1iZXI7XG4gIGNvbW1vblByb3BzPzogQztcbn07XG50eXBlIFN0YXRlID0ge1xuICB1c2VBYnNvbHV0ZVBvc2l0aW9uaW5nOiBib29sZWFuO1xuICBkcmFnZ2luZzogYm9vbGVhbjtcbiAgbGFzdERyYWc6ID9EcmFnO1xuICBoZWlnaHRzOiA/e1trZXk6IHN0cmluZ106IEhlaWdodERhdGF9O1xufTtcbnR5cGUgRGVmYXVsdFByb3BzID0ge1xuICBzcHJpbmdDb25maWc6IE9iamVjdDtcbiAgY29uc3RyYWluRHJhZzogYm9vbGVhbjtcbiAgcGFkZGluZzogbnVtYmVyO1xuICB1bnNldFpJbmRleDogYm9vbGVhbjtcbiAgYXV0b1Njcm9sbE1heFNwZWVkOiBudW1iZXI7XG4gIGF1dG9TY3JvbGxSZWdpb25TaXplOiBudW1iZXI7XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhZ2dhYmxlTGlzdDxJLEM9KixUOlJlYWN0LkNvbXBvbmVudDwkU2hhcGU8VGVtcGxhdGVQcm9wczxJLEM+PiwqPj0qPiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wczxJLEMsVD4sIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgaXRlbUtleTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUHJvcFR5cGVzLmZ1bmNcbiAgICBdKS5pc1JlcXVpcmVkLFxuICAgIHRlbXBsYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBsaXN0OiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBvbk1vdmVFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGNvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc3ByaW5nQ29uZmlnOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGNvbnN0cmFpbkRyYWc6IFByb3BUeXBlcy5ib29sLFxuICAgIHBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdW5zZXRaSW5kZXg6IFByb3BUeXBlcy5ib29sLFxuICAgIGF1dG9TY3JvbGxNYXhTcGVlZDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGF1dG9TY3JvbGxSZWdpb25TaXplOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgY29tbW9uUHJvcHM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgc3RhdGljIGRlZmF1bHRQcm9wczogRGVmYXVsdFByb3BzID0ge1xuICAgIHNwcmluZ0NvbmZpZzoge3N0aWZmbmVzczogMzAwLCBkYW1waW5nOiA1MH0sXG4gICAgcGFkZGluZzogMTAsXG4gICAgdW5zZXRaSW5kZXg6IGZhbHNlLFxuICAgIGNvbnN0cmFpbkRyYWc6IGZhbHNlLFxuICAgIGF1dG9TY3JvbGxNYXhTcGVlZDogMTUsXG4gICAgYXV0b1Njcm9sbFJlZ2lvblNpemU6IDMwXG4gIH07XG4gIF9pdGVtUmVmczogTXVsdGlSZWY8c3RyaW5nLCBNb3ZlQ29udGFpbmVyPEksYW55LFQ+PiA9IG5ldyBNdWx0aVJlZigpO1xuICBfYXV0b1Njcm9sbGVyVGltZXI6IGFueTtcblxuICBfbGlzdFJlZiA9IFJlYWN0LmNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8SSxDLFQ+KSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB1c2VBYnNvbHV0ZVBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGxhc3REcmFnOiBudWxsLFxuICAgICAgaGVpZ2h0czogbnVsbFxuICAgIH07XG4gIH1cblxuICBnZXRJdGVtSW5zdGFuY2Uoa2V5OiBzdHJpbmcpOiBUIHtcbiAgICBjb25zdCByZWYgPSB0aGlzLl9pdGVtUmVmcy5tYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFyZWYpIHRocm93IG5ldyBFcnJvcigna2V5IG5vdCBmb3VuZCcpO1xuICAgIHJldHVybiByZWYuZ2V0VGVtcGxhdGUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM8SSxDLFQ+KG5ld1Byb3BzOiBQcm9wczxJLEMsVD4sIHN0YXRlOiBTdGF0ZSk6ICRTaGFwZTxTdGF0ZT58bnVsbCB7XG4gICAgY29uc3Qge2xpc3R9ID0gbmV3UHJvcHM7XG4gICAgY29uc3Qge2xhc3REcmFnfSA9IHN0YXRlO1xuXG4gICAgaWYgKGxhc3REcmFnKSB7XG4gICAgICBjb25zdCBrZXlGbiA9IERyYWdnYWJsZUxpc3QuX2dldEtleUZuPEk+KG5ld1Byb3BzLml0ZW1LZXkpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBEcmFnZ2FibGVMaXN0Ll9nZXRJbmRleE9mSXRlbVdpdGhLZXk8ST4oa2V5Rm4sIGxpc3QsIGxhc3REcmFnLml0ZW1LZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIHRoZSBkcmFnZ2VkIGl0ZW0gd2FzIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCwgdGhpcyBibG9jayB3aWxsIGdldCBoaXQuXG4gICAgICAgIC8vIENhbmNlbCB0aGUgZHJhZy5cbiAgICAgICAgcmV0dXJuIHtkcmFnZ2luZzogZmFsc2UsIGxhc3REcmFnOiBudWxsfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2hhbmRsZU1vdXNlVXAoKTtcbiAgfVxuXG4gIF9oYW5kbGVUb3VjaFN0YXJ0KGl0ZW1LZXk6IHN0cmluZywgcHJlc3NZOiA/bnVtYmVyLCBldmVudDogT2JqZWN0KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faGFuZGxlU3RhcnREcmFnKGl0ZW1LZXksIHByZXNzWSwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSk7XG4gIH1cblxuICBfaGFuZGxlTW91c2VEb3duKGl0ZW1LZXk6IHN0cmluZywgcHJlc3NZOiA/bnVtYmVyLCBldmVudDogT2JqZWN0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLl9oYW5kbGVTdGFydERyYWcoaXRlbUtleSwgcHJlc3NZLCBldmVudC5wYWdlWSk7XG4gIH1cblxuICBfaGFuZGxlU3RhcnREcmFnKGl0ZW1LZXk6IHN0cmluZywgcHJlc3NZOiA/bnVtYmVyLCBwYWdlWTogbnVtYmVyKSB7XG4gICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaE1vdmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuXG4gICAgLy8gSWYgYW4gZWxlbWVudCBoYXMgZm9jdXMgd2hpbGUgd2UgZHJhZyBhcm91bmQgdGhlIHBhcmVudCwgc29tZSBicm93c2Vyc1xuICAgIC8vIHRyeSB0byBzY3JvbGwgdGhlIHBhcmVudCBlbGVtZW50IHRvIGtlZXAgdGhlIGZvY3VzZWQgZWxlbWVudCBpbiB2aWV3LlxuICAgIC8vIFN0b3AgdGhhdC5cbiAgICB7XG4gICAgICBjb25zdCBsaXN0RWwgPSB0aGlzLl9saXN0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWxpc3RFbCkgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGhhcHBlbicpO1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0RWwuY29udGFpbnMgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICBsaXN0RWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAgICkge1xuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXlGbiA9IHRoaXMuX2dldEtleUZuKCk7XG5cbiAgICBsZXQgbmV3SGVpZ2h0cyA9IG51bGw7XG4gICAgaWYgKHRoaXMuc3RhdGUuaGVpZ2h0cyA9PSBudWxsKSB7XG4gICAgICBjb25zdCBfbmV3SGVpZ2h0czoge1trZXk6IHN0cmluZ106IEhlaWdodERhdGF9ID0gKE9iamVjdC5jcmVhdGUobnVsbCk6IGFueSk7XG5cbiAgICAgIHRoaXMucHJvcHMubGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlGbihpdGVtKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVmID0gdGhpcy5faXRlbVJlZnMubWFwLmdldChrZXkpO1xuICAgICAgICBjb25zdCByZWZFbCA9IGNvbnRhaW5lclJlZiA/IGNvbnRhaW5lclJlZi5nZXRET01Ob2RlKCkuZmlyc3RFbGVtZW50Q2hpbGQgOiBudWxsO1xuICAgICAgICBjb25zdCByZWYgPSBjb250YWluZXJSZWYgPyBjb250YWluZXJSZWYuZ2V0VGVtcGxhdGUoKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IG5hdHVyYWwgPSAocmVmRWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgP1xuICAgICAgICAgIHJlZkVsLm9mZnNldEhlaWdodCA6IERFRkFVTFRfSEVJR0hULm5hdHVyYWw7XG4gICAgICAgIGNvbnN0IGRyYWcgPSByZWYgJiYgKHR5cGVvZiAocmVmOiBhbnkpLmdldERyYWdIZWlnaHQgPT09ICdmdW5jdGlvbicpICYmIChyZWY6IGFueSkuZ2V0RHJhZ0hlaWdodCgpIHx8IG5hdHVyYWw7XG5cbiAgICAgICAgX25ld0hlaWdodHNba2V5XSA9IHtuYXR1cmFsLCBkcmFnfTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdIZWlnaHRzID0gX25ld0hlaWdodHM7XG4gICAgfVxuXG4gICAgLy8gTmVlZCB0byByZS1yZW5kZXIgb25jZSBiZWZvcmUgd2Ugc3RhcnQgZHJhZ2dpbmcgc28gdGhhdCB0aGUgYHlgIHZhbHVlc1xuICAgIC8vIGFyZSBzZXQgdXNpbmcgdGhlIGNvcnJlY3Qgc3RhdGUuaGVpZ2h0cyBhbmQgdGhlbiBjYW4gYW5pbWF0ZSBmcm9tIHRoZXJlLlxuXG4gICAgY29uc3QgYWZ0ZXJIZWlnaHRzID0gKCkgPT4ge1xuICAgICAgY29uc3QgaXRlbUluZGV4ID0gdGhpcy5wcm9wcy5saXN0Lm1hcChrZXlGbikuaW5kZXhPZihpdGVtS2V5KTtcblxuICAgICAgLy8gcHJlc3NZIHdpbGwgYmUgbm9uLW51bGwgaWYgdGhlIGxpc3QgaXMgY3VycmVudGx5IGFuaW1hdGluZyAoYmVjYXVzZSB0aGVcbiAgICAgIC8vIGNsaWNrZWQgaXRlbSBoYXMgaXRzIGB5YCBwcm9wIHNldCkuIHByZXNzWSB3aWxsIGJlIG51bGwgaWYgdGhlIGxpc3QgaXNcbiAgICAgIC8vIG5vdCBjdXJyZW50bHkgYW5pbWF0aW5nIChiZWNhdXNlIHRoZSBjbGlja2VkIGl0ZW0gd2lsbCBiZSBhdCBpdHNcbiAgICAgIC8vIG5hdHVyYWwgcG9zaXRpb24sIHdoaWNoIGlzIGNhbGN1bGF0YWJsZSB1c2luZyBfZ2V0RGlzdGFuY2UpLlxuICAgICAgY29uc3Qgc3RhcnRZID0gcHJlc3NZID09IG51bGwgP1xuICAgICAgICB0aGlzLl9nZXREaXN0YW5jZSgwLCBpdGVtSW5kZXgsIGZhbHNlKSA6IHByZXNzWTtcblxuICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbCA9ICFjb250YWluZXJFbCB8fCBjb250YWluZXJFbCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgIDAgOiBjb250YWluZXJFbC5zY3JvbGxUb3A7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB1c2VBYnNvbHV0ZVBvc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgbGFzdERyYWc6IHtcbiAgICAgICAgICBpdGVtS2V5OiBpdGVtS2V5LFxuICAgICAgICAgIHN0YXJ0WSxcbiAgICAgICAgICBtb3VzZVk6IHN0YXJ0WSxcbiAgICAgICAgICBtb3VzZU9mZnNldDogcGFnZVkgLSBzdGFydFkgKyBjb250YWluZXJTY3JvbGxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChuZXdIZWlnaHRzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtoZWlnaHRzOiBuZXdIZWlnaHRzfSwgYWZ0ZXJIZWlnaHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJIZWlnaHRzKCk7XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZVRvdWNoTW92ZTogRnVuY3Rpb24gPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUoZS50b3VjaGVzWzBdKTtcbiAgfTtcblxuICBfaGFuZGxlTW91c2VNb3ZlOiBGdW5jdGlvbiA9ICh7cGFnZVksIGNsaWVudFl9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdCxcbiAgICAgIGF1dG9TY3JvbGxNYXhTcGVlZCxcbiAgICAgIGF1dG9TY3JvbGxSZWdpb25TaXplXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2RyYWdnaW5nLCBsYXN0RHJhZ30gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghZHJhZ2dpbmcgfHwgIWxhc3REcmFnKSByZXR1cm47XG5cbiAgICBjb25zdCBjb250YWluZXJFbCA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIGNvbnN0IGRyYWdWaXN1YWxJbmRleCA9IHRoaXMuX2dldERyYWdWaXN1YWxJbmRleCgpO1xuICAgIGNvbnN0IGtleUZuID0gdGhpcy5fZ2V0S2V5Rm4oKTtcblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fYXV0b1Njcm9sbGVyVGltZXIpO1xuXG4gICAgLy8gSWYgdGhlIHVzZXIgaGFzIHRoZSBtb3VzZSBuZWFyIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSBjb250YWluZXIgYW5kXG4gICAgLy8gbm90IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZW4gYXV0b3Njcm9sbC5cbiAgICBpZiAoZHJhZ1Zpc3VhbEluZGV4ICE9PSAwICYmIGRyYWdWaXN1YWxJbmRleCAhPT0gbGlzdC5sZW5ndGgtMSkge1xuICAgICAgbGV0IHNjcm9sbFNwZWVkID0gMDtcblxuICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lckVsICYmIGNvbnRhaW5lckVsICE9PSBkb2N1bWVudC5ib2R5ICYmXG4gICAgICAgIGNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/XG4gICAgICAgIGNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDpcbiAgICAgICAge3RvcDogMCwgYm90dG9tOiBJbmZpbml0eX07XG5cbiAgICAgIC8vIEdldCB0aGUgbG93ZXN0IG9mIHRoZSBzY3JlZW4gdG9wIGFuZCB0aGUgY29udGFpbmVyIHRvcC5cbiAgICAgIGNvbnN0IHRvcCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lclJlY3QudG9wKTtcblxuICAgICAgY29uc3QgZGlzdGFuY2VGcm9tVG9wID0gY2xpZW50WS10b3A7XG4gICAgICBpZiAoZGlzdGFuY2VGcm9tVG9wID4gMCAmJiBkaXN0YW5jZUZyb21Ub3AgPCBhdXRvU2Nyb2xsUmVnaW9uU2l6ZSkge1xuICAgICAgICBzY3JvbGxTcGVlZCA9IC0xICogZ2V0U2Nyb2xsU3BlZWQoZGlzdGFuY2VGcm9tVG9wLCBhdXRvU2Nyb2xsTWF4U3BlZWQsIGF1dG9TY3JvbGxSZWdpb25TaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgbG93ZXN0IG9mIHRoZSBzY3JlZW4gYm90dG9tIGFuZCB0aGUgY29udGFpbmVyIGJvdHRvbS5cbiAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCBjb250YWluZXJSZWN0LmJvdHRvbSk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbUJvdHRvbSA9IGJvdHRvbS1jbGllbnRZO1xuICAgICAgICBpZiAoZGlzdGFuY2VGcm9tQm90dG9tID4gMCAmJiBkaXN0YW5jZUZyb21Cb3R0b20gPCBhdXRvU2Nyb2xsUmVnaW9uU2l6ZSkge1xuICAgICAgICAgIHNjcm9sbFNwZWVkID0gZ2V0U2Nyb2xsU3BlZWQoZGlzdGFuY2VGcm9tQm90dG9tLCBhdXRvU2Nyb2xsTWF4U3BlZWQsIGF1dG9TY3JvbGxSZWdpb25TaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2Nyb2xsU3BlZWQgIT09IDApIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQ29udGFpbmVyKHNjcm9sbFNwZWVkKTtcbiAgICAgICAgdGhpcy5fYXV0b1Njcm9sbGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUoe1xuICAgICAgICAgICAgcGFnZVk6IHBhZ2VZICsgKGNvbnRhaW5lckVsPT09ZG9jdW1lbnQuYm9keT9zY3JvbGxTcGVlZDowKSxcbiAgICAgICAgICAgIGNsaWVudFlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lclNjcm9sbCA9ICFjb250YWluZXJFbCB8fCBjb250YWluZXJFbCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAwIDogY29udGFpbmVyRWwuc2Nyb2xsVG9wO1xuICAgIGxldCBtb3VzZVkgPSBwYWdlWSAtIGxhc3REcmFnLm1vdXNlT2Zmc2V0ICsgY29udGFpbmVyU2Nyb2xsO1xuICAgIGlmICh0aGlzLnByb3BzLmNvbnN0cmFpbkRyYWcpIHtcbiAgICAgIGNvbnN0IHZpc3VhbExpc3QgPSB0aGlzLl9nZXRWaXN1YWxMaXN0RHVyaW5nRHJhZygpO1xuXG4gICAgICBtb3VzZVkgPSBNYXRoLm1heChtb3VzZVksIHRoaXMuX2dldERpc3RhbmNlRnJvbVRvcER1cmluZ0RyYWcobGFzdERyYWcsIGtleUZuKHZpc3VhbExpc3RbMF0pLCB2aXN1YWxMaXN0KSk7XG4gICAgICBtb3VzZVkgPSBNYXRoLm1pbihtb3VzZVksIHRoaXMuX2dldERpc3RhbmNlRnJvbVRvcER1cmluZ0RyYWcobGFzdERyYWcsIGtleUZuKHZpc3VhbExpc3RbdmlzdWFsTGlzdC5sZW5ndGggLSAxXSksIHZpc3VhbExpc3QpKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtsYXN0RHJhZzogey4uLmxhc3REcmFnLCBtb3VzZVl9fSk7XG4gIH07XG5cbiAgX2hhbmRsZU1vdXNlVXA6IEZ1bmN0aW9uID0gKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fYXV0b1Njcm9sbGVyVGltZXIpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG5cbiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgdGhpcy5fbGFzdFNjcm9sbERlbHRhID0gMDtcblxuICAgIGNvbnN0IHtsaXN0LCBvbk1vdmVFbmR9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7ZHJhZ2dpbmcsIGxhc3REcmFnfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAoZHJhZ2dpbmcgJiYgbGFzdERyYWcgJiYgb25Nb3ZlRW5kKSB7XG4gICAgICBjb25zdCBkcmFnSW5kZXggPSB0aGlzLl9nZXREcmFnTGlzdEluZGV4KCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2dldERyYWdWaXN1YWxJbmRleCgpO1xuXG4gICAgICBpZiAoZHJhZ0luZGV4ICE9PSBuZXdJbmRleCkge1xuICAgICAgICBjb25zdCBuZXdMaXN0ID0gdGhpcy5fZ2V0VmlzdWFsTGlzdER1cmluZ0RyYWcoKTtcblxuICAgICAgICBvbk1vdmVFbmQobmV3TGlzdCwgbGlzdFtkcmFnSW5kZXhdLCBkcmFnSW5kZXgsIG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoe2RyYWdnaW5nOiBmYWxzZX0pO1xuICAgIH1cbiAgfTtcblxuICBfc2Nyb2xsQ29udGFpbmVyKGRlbHRhOiBudW1iZXIpIHtcbiAgICBjb25zdCBjb250YWluZXJFbCA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIGlmICghY29udGFpbmVyRWwpIHJldHVybjtcbiAgICBpZiAod2luZG93LnNjcm9sbEJ5ICYmIGNvbnRhaW5lckVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgZGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXJFbC5zY3JvbGxUb3AgKz0gZGVsdGE7XG4gICAgfVxuICB9XG5cbiAgX2xhc3RTY3JvbGxEZWx0YTogbnVtYmVyID0gMDtcbiAgX2FkanVzdFNjcm9sbEF0RW5kKGRlbHRhOiBudW1iZXIpIHtcbiAgICBjb25zdCBmcmFtZURlbHRhID0gTWF0aC5yb3VuZChkZWx0YSAtIHRoaXMuX2xhc3RTY3JvbGxEZWx0YSk7XG4gICAgdGhpcy5fc2Nyb2xsQ29udGFpbmVyKGZyYW1lRGVsdGEpO1xuICAgIHRoaXMuX2xhc3RTY3JvbGxEZWx0YSArPSBmcmFtZURlbHRhO1xuICB9XG5cbiAgc3RhdGljIF9nZXRJbmRleE9mSXRlbVdpdGhLZXk8ST4oa2V5Rm46IChpdGVtOiBJKSA9PiBzdHJpbmcsIGxpc3Q6ICRSZWFkT25seUFycmF5PEk+LCBpdGVtS2V5OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGZvciAobGV0IGk9MCwgbGVuPWxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChrZXlGbihsaXN0W2ldKSA9PT0gaXRlbUtleSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBkcmFnIGluZGV4Jyk7XG4gIH1cblxuICBfZ2V0RHJhZ0xpc3RJbmRleCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHtsaXN0fSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2xhc3REcmFnfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFsYXN0RHJhZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkcmFnIGhhcHBlbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleUZuID0gdGhpcy5fZ2V0S2V5Rm4oKTtcbiAgICByZXR1cm4gRHJhZ2dhYmxlTGlzdC5fZ2V0SW5kZXhPZkl0ZW1XaXRoS2V5KGtleUZuLCBsaXN0LCBsYXN0RHJhZy5pdGVtS2V5KTtcbiAgfVxuXG4gIF9nZXREcmFnVmlzdWFsSW5kZXgoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7bGlzdCwgcGFkZGluZ30gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtkcmFnZ2luZywgbGFzdERyYWd9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWRyYWdnaW5nIHx8ICFsYXN0RHJhZykgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGhhcHBlbicpO1xuXG4gICAgY29uc3QgZHJhZ0xpc3RJbmRleCA9IHRoaXMuX2dldERyYWdMaXN0SW5kZXgoKTtcblxuICAgIGNvbnN0IHttb3VzZVksIHN0YXJ0WX0gPSBsYXN0RHJhZztcblxuICAgIGNvbnN0IG1vdmVtZW50RnJvbU5hdHVyYWwgPSBtb3VzZVktc3RhcnRZO1xuICAgIC8vIDEgZG93biwgLTEgdXAsIDAgbmVpdGhlclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG1vdmVtZW50RnJvbU5hdHVyYWwgPiAwID8gMSA6XG4gICAgICBtb3ZlbWVudEZyb21OYXR1cmFsIDwgMCA/IC0xIDogMDtcbiAgICBsZXQgbmV3SW5kZXggPSBkcmFnTGlzdEluZGV4O1xuICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgIGNvbnN0IGtleUZuID0gdGhpcy5fZ2V0S2V5Rm4oKTtcbiAgICAgIGxldCByZWFjaCA9IE1hdGguYWJzKG1vdmVtZW50RnJvbU5hdHVyYWwpO1xuICAgICAgZm9yIChsZXQgaT1kcmFnTGlzdEluZGV4K2RpcmVjdGlvbjsgaSA8IGxpc3QubGVuZ3RoICYmIGkgPj0gMDsgaSArPSBkaXJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaURyYWdIZWlnaHQgPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGtleUZuKGxpc3RbaV0pKS5kcmFnO1xuICAgICAgICBpZiAocmVhY2ggPCBpRHJhZ0hlaWdodC8yICsgcGFkZGluZykgYnJlYWs7XG4gICAgICAgIHJlYWNoIC09IGlEcmFnSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgbmV3SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdJbmRleDtcbiAgfVxuXG4gIF9nZXRWaXN1YWxMaXN0RHVyaW5nRHJhZygpOiAkUmVhZE9ubHlBcnJheTxJPiB7XG4gICAgY29uc3Qge2xpc3R9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7ZHJhZ2dpbmcsIGxhc3REcmFnfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFkcmFnZ2luZyB8fCAhbGFzdERyYWcpIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBoYXBwZW46IF9nZXRWaXN1YWxMaXN0RHVyaW5nRHJhZyBjYWxsZWQgb3V0c2lkZSBvZiBkcmFnJyk7XG5cbiAgICBjb25zdCBkcmFnTGlzdEluZGV4ID0gdGhpcy5fZ2V0RHJhZ0xpc3RJbmRleCgpO1xuICAgIGNvbnN0IGRyYWdWaXN1YWxJbmRleCA9IHRoaXMuX2dldERyYWdWaXN1YWxJbmRleCgpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZShsaXN0LCB7XG4gICAgICAkc3BsaWNlOiBbW2RyYWdMaXN0SW5kZXgsIDFdLCBbZHJhZ1Zpc3VhbEluZGV4LCAwLCBsaXN0W2RyYWdMaXN0SW5kZXhdXV1cbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRJdGVtSGVpZ2h0KGtleTogc3RyaW5nKTogSGVpZ2h0RGF0YSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaGVpZ2h0cyAhPSBudWxsICYmIGtleSBpbiB0aGlzLnN0YXRlLmhlaWdodHMgP1xuICAgICAgdGhpcy5zdGF0ZS5oZWlnaHRzW2tleV0gOiBERUZBVUxUX0hFSUdIVDtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdG9wcyBvZiB0d28gaXRlbXMgaW4gdGhlIGxpc3QuXG4gIC8vIERvZXMgbm90IGNvbnNpZGVyIGhvdyB0aGUgZHJhZ2dlZCBpdGVtIG1heSBiZSByZW5kZXJlZCBpbiBhIGRpZmZlcmVudCBwb3NpdGlvblxuICAvLyB1bmxlc3MgeW91IHBhc3MgaW4gdGhlIHJlLW9yZGVyZWQgbGlzdCBhcyBhIHBhcmFtZXRlci5cbiAgX2dldERpc3RhbmNlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBkcmFnZ2luZzogYm9vbGVhbiwgbGlzdDogJFJlYWRPbmx5QXJyYXk8ST4gPSB0aGlzLnByb3BzLmxpc3QpOiBudW1iZXIge1xuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgcmV0dXJuIC10aGlzLl9nZXREaXN0YW5jZShlbmQsIHN0YXJ0LCBkcmFnZ2luZywgbGlzdCk7XG4gICAgfVxuXG4gICAgY29uc3Qge3BhZGRpbmd9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBrZXlGbiA9IHRoaXMuX2dldEtleUZuKCk7XG4gICAgbGV0IGRpc3RhbmNlID0gMDtcbiAgICBmb3IgKGxldCBpPXN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2dldEl0ZW1IZWlnaHQoa2V5Rm4obGlzdFtpXSkpO1xuICAgICAgZGlzdGFuY2UgKz0gKGRyYWdnaW5nID8gaGVpZ2h0LmRyYWcgOiBoZWlnaHQubmF0dXJhbCkgKyBwYWRkaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZGlzdGFuY2U7XG4gIH1cblxuICBfZ2V0RGlzdGFuY2VGcm9tVG9wRHVyaW5nRHJhZyhsYXN0RHJhZzogRHJhZywgaXRlbUtleTogc3RyaW5nLCB2aXN1YWxMaXN0OiAkUmVhZE9ubHlBcnJheTxJPik6IG51bWJlciB7XG4gICAgY29uc3Qga2V5Rm4gPSB0aGlzLl9nZXRLZXlGbigpO1xuICAgIGNvbnN0IGluZGV4ID0gRHJhZ2dhYmxlTGlzdC5fZ2V0SW5kZXhPZkl0ZW1XaXRoS2V5KGtleUZuLCB2aXN1YWxMaXN0LCBpdGVtS2V5KTtcbiAgICBjb25zdCBkcmFnTGlzdEluZGV4ID0gdGhpcy5fZ2V0RHJhZ0xpc3RJbmRleCgpO1xuICAgIGNvbnN0IGRyYWdWaXN1YWxJbmRleCA9IERyYWdnYWJsZUxpc3QuX2dldEluZGV4T2ZJdGVtV2l0aEtleShrZXlGbiwgdmlzdWFsTGlzdCwgbGFzdERyYWcuaXRlbUtleSk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBpZiAoZHJhZ1Zpc3VhbEluZGV4IDwgZHJhZ0xpc3RJbmRleCkge1xuICAgICAgY29uc3QgZHJhZ0l0ZW1IZWlnaHQgPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGxhc3REcmFnLml0ZW1LZXkpO1xuICAgICAgY29uc3QgbmV3Q2VudGVySGVpZ2h0ID1cbiAgICAgICAgdGhpcy5fZ2V0SXRlbUhlaWdodChrZXlGbih2aXN1YWxMaXN0W2RyYWdMaXN0SW5kZXhdKSk7XG4gICAgICBvZmZzZXQgPSBkcmFnSXRlbUhlaWdodC5kcmFnIC0gbmV3Q2VudGVySGVpZ2h0LmRyYWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3REcmFnLnN0YXJ0WSArIG9mZnNldCArXG4gICAgICB0aGlzLl9nZXREaXN0YW5jZShkcmFnTGlzdEluZGV4LCBpbmRleCwgdHJ1ZSwgdmlzdWFsTGlzdCk7XG4gIH1cblxuICBfZ2V0Q29udGFpbmVyKCk6ID9IVE1MRWxlbWVudCB7XG4gICAgY29uc3Qge2NvbnRhaW5lcn0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBjb250YWluZXIgPyBjb250YWluZXIoKSA6IG51bGw7XG4gIH1cblxuICBzdGF0aWMgX2dldEtleUZuPEk+KGl0ZW1LZXk6IHN0cmluZ3woaXRlbTogSSk9PnN0cmluZyk6IChpdGVtOiBJKSA9PiBzdHJpbmcge1xuICAgIHJldHVybiB0eXBlb2YgaXRlbUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZW1LZXkgOiB4ID0+ICh4OiBhbnkpW2l0ZW1LZXldO1xuICB9XG5cbiAgX2dldEtleUZuKCk6IChpdGVtOiBJKSA9PiBzdHJpbmcge1xuICAgIHJldHVybiBEcmFnZ2FibGVMaXN0Ll9nZXRLZXlGbjxJPih0aGlzLnByb3BzLml0ZW1LZXkpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtsaXN0LCBzcHJpbmdDb25maWcsIGNvbnRhaW5lciwgcGFkZGluZywgdGVtcGxhdGUsIHVuc2V0WkluZGV4LCBjb21tb25Qcm9wc30gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtkcmFnZ2luZywgbGFzdERyYWcsIHVzZUFic29sdXRlUG9zaXRpb25pbmd9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGtleUZuID0gdGhpcy5fZ2V0S2V5Rm4oKTtcbiAgICBjb25zdCBhbnlTZWxlY3RlZCA9IHNwcmluZyhkcmFnZ2luZyA/IDEgOiAwLCBzcHJpbmdDb25maWcpO1xuXG4gICAgY29uc3QgdmlzdWFsTGlzdCA9IGRyYWdnaW5nID8gdGhpcy5fZ2V0VmlzdWFsTGlzdER1cmluZ0RyYWcoKSA6IGxpc3Q7XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IGxpc3QubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlGbihpdGVtKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBkcmFnZ2luZyAmJiBsYXN0RHJhZyAmJiBsYXN0RHJhZy5pdGVtS2V5ID09PSBrZXlcbiAgICAgICAgPyB7XG4gICAgICAgICAgaXRlbVNlbGVjdGVkOiBzcHJpbmcoMSwgc3ByaW5nQ29uZmlnKSxcbiAgICAgICAgICB5OiBsYXN0RHJhZy5tb3VzZVlcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICBpdGVtU2VsZWN0ZWQ6IHNwcmluZygwLCBzcHJpbmdDb25maWcpLFxuICAgICAgICAgIHk6ICh1c2VBYnNvbHV0ZVBvc2l0aW9uaW5nID8gc3ByaW5nIDogKHgsaWdub3JlZCk9PngpKGRyYWdnaW5nICYmIGxhc3REcmFnID9cbiAgICAgICAgICAgIHRoaXMuX2dldERpc3RhbmNlRnJvbVRvcER1cmluZ0RyYWcobGFzdERyYWcsIGtleSwgdmlzdWFsTGlzdClcbiAgICAgICAgICAgIDogdGhpcy5fZ2V0RGlzdGFuY2UoMCwgaSwgZmFsc2UpLCBzcHJpbmdDb25maWcpXG4gICAgICAgIH07XG4gICAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgYW55U2VsZWN0ZWQsXG4gICAgICAgIC4uLnNlbGVjdGVkU3R5bGVcbiAgICAgIH07XG4gICAgICBjb25zdCBtYWtlRHJhZ0hhbmRsZVByb3BzID0gKGdldFk6ICgpPT4/bnVtYmVyKTogT2JqZWN0ID0+ICh7XG4gICAgICAgIG9uTW91c2VEb3duOiBlID0+IHRoaXMuX2hhbmRsZU1vdXNlRG93bihrZXksIGdldFkoKSwgZSksXG4gICAgICAgIG9uVG91Y2hTdGFydDogZSA9PiB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KGtleSwgZ2V0WSgpLCBlKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGtleSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8TW90aW9uXG4gICAgICAgICAgc3R5bGU9e3N0eWxlfSBrZXk9e2tleX1cbiAgICAgICAgICBjaGlsZHJlbj17KHtpdGVtU2VsZWN0ZWQsIGFueVNlbGVjdGVkLCB5fSkgPT5cbiAgICAgICAgICAgIDxNb3ZlQ29udGFpbmVyXG4gICAgICAgICAgICAgIHJlZj17dGhpcy5faXRlbVJlZnMucmVmKGtleSl9XG4gICAgICAgICAgICAgIHk9e3VzZUFic29sdXRlUG9zaXRpb25pbmcgPyB5IDogbnVsbH1cbiAgICAgICAgICAgICAgdGVtcGxhdGU9e3RlbXBsYXRlfVxuICAgICAgICAgICAgICBwYWRkaW5nPXtwYWRkaW5nfVxuICAgICAgICAgICAgICBpdGVtPXtpdGVtfVxuICAgICAgICAgICAgICBpdGVtU2VsZWN0ZWQ9e2l0ZW1TZWxlY3RlZH1cbiAgICAgICAgICAgICAgYW55U2VsZWN0ZWQ9e2FueVNlbGVjdGVkfVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgekluZGV4PXt1bnNldFpJbmRleCAmJiAhdXNlQWJzb2x1dGVQb3NpdGlvbmluZyA/ICdhdXRvJyA6XG4gICAgICAgICAgICAgICAgKGxhc3REcmFnICYmIGxhc3REcmFnLml0ZW1LZXkgPT09IGtleSA/IGxpc3QubGVuZ3RoIDogaSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYWtlRHJhZ0hhbmRsZVByb3BzPXttYWtlRHJhZ0hhbmRsZVByb3BzfVxuICAgICAgICAgICAgICBjb21tb25Qcm9wcz17Y29tbW9uUHJvcHN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBsZXQgYWRqdXN0U2Nyb2xsID0gMDtcbiAgICBpZiAoIWRyYWdnaW5nICYmIGxhc3REcmFnICYmIHVzZUFic29sdXRlUG9zaXRpb25pbmcpIHtcbiAgICAgIGNvbnN0IGRyYWdMaXN0SW5kZXggPSB0aGlzLl9nZXREcmFnTGlzdEluZGV4KCk7XG4gICAgICBhZGp1c3RTY3JvbGwgPSBzcHJpbmcoXG4gICAgICAgIHRoaXMuX2dldERpc3RhbmNlKDAsIGRyYWdMaXN0SW5kZXgsIGZhbHNlKVxuICAgICAgICAtIGxhc3REcmFnLm1vdXNlWSxcbiAgICAgICAgc3ByaW5nQ29uZmlnXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBoZWlnaHRSZXNlcnZlckhlaWdodCA9IDA7XG4gICAgbGV0IGhlaWdodFJlc2VydmVyTWFyZ2luQm90dG9tID0gMDtcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGhlaWdodFJlc2VydmVyTWFyZ2luQm90dG9tID0gcGFkZGluZztcbiAgICAgIGlmICh1c2VBYnNvbHV0ZVBvc2l0aW9uaW5nKSB7XG4gICAgICAgIGhlaWdodFJlc2VydmVySGVpZ2h0ID0gdGhpcy5fZ2V0RGlzdGFuY2UoMCwgbGlzdC5sZW5ndGgsIGZhbHNlKSAtIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPXt7cG9zaXRpb246ICdyZWxhdGl2ZSd9fVxuICAgICAgICByZWY9e3RoaXMuX2xpc3RSZWZ9XG4gICAgICA+XG4gICAgICAgIDxNb3Rpb25cbiAgICAgICAgICBzdHlsZT17e2FkanVzdFNjcm9sbCwgYW55U2VsZWN0ZWR9fVxuICAgICAgICAgIG9uUmVzdD17KCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBoZWlnaHRzOiBudWxsLFxuICAgICAgICAgICAgICAgIHVzZUFic29sdXRlUG9zaXRpb25pbmc6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgICAgY2hpbGRyZW49eyh7YWRqdXN0U2Nyb2xsfSkgPT5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiB1c2VBYnNvbHV0ZVBvc2l0aW9uaW5nID8gJ2Jsb2NrJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2hlaWdodFJlc2VydmVySGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IGAke2hlaWdodFJlc2VydmVyTWFyZ2luQm90dG9tfXB4YFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7Y29udGFpbmVyICYmIDxPblVwZGF0ZSBjYj17KCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZHJhZ2dpbmcgJiYgbGFzdERyYWcgJiYgdXNlQWJzb2x1dGVQb3NpdGlvbmluZykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0U2Nyb2xsQXRFbmQoYWRqdXN0U2Nyb2xsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH19IC8+fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgfVxuICAgICAgICAvPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iXX0=